<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>å¯„ã‚Šé“ã®æ•£æ­©ã‚²ãƒ¼ãƒ </title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    body{font-family:'Noto Sans JP',sans-serif;margin:0;min-height:100vh;
      background:linear-gradient(135deg,#667eea 0%,#764ba2 100%)}
    .game-container{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;padding:20px}
    .pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
    .bob { animation: bob 2.6s ease-in-out infinite; }
    @keyframes bob { 0%{transform:translateY(0)} 50%{transform:translateY(-6px)} 100%{transform:translateY(0)} }
    .face-left { transform: scaleX(-1); }
    /* å¸ã„è¾¼ã¿ç©´ã®è¦–è¦šåŠ¹æœ */
    .hole{position:absolute;border-radius:50%;overflow:hidden}
    .hole::before,
    .hole::after{
      content:"";position:absolute;inset:-20%;border-radius:50%;
      background: conic-gradient(from 0deg, rgba(255,255,255,.06), rgba(0,0,0,0) 30%, rgba(255,255,255,.06) 60%, rgba(0,0,0,0) 90%);
      animation:spin 2.5s linear infinite;
      filter: blur(4px);
    }
    .hole::after{animation-duration:4s;opacity:.6}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    /* =========================
       ç”»åƒãƒ‘ã‚¹ã®è‡ªå‹•è§£æ±º
    ========================= */
    const repoPrefix = (()=>{ // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒšãƒ¼ã‚¸ã§ã‚‚å‹•ãã‚ˆã†ã«
      const seg = location.pathname.split('/').filter(Boolean)[0];
      return seg ? `/${seg}/` : '/';
    })();

    const fileNames = {
      green: ["green.png","green_open.png","green_closed.png"],
      pink:  ["pink.png","pink_open.png","pink_open - ã‚³ãƒ”ãƒ¼.png"],
      blue:  ["blue.png","blue_closed.png","blue_closed - ã‚³ãƒ”ãƒ¼.png"],
      purple:["purple.png","purple_closed.png","purple_closed - ã‚³ãƒ”ãƒ¼.png"],
    };

    const bases = [
      "", "./", "/", repoPrefix,
      "public/characters/", "./public/characters/", repoPrefix+"public/characters/",
      "characters/", "./characters/", repoPrefix+"characters/",
      "public/assets/stage1/", "./public/assets/stage1/", repoPrefix+"public/assets/stage1/"
    ];

    function buildCandidates(color){
      const enc = n=>n.replace(/ /g,"%20");
      const names = fileNames[color] || [color+".png"];
      const list = [];
      for(const b of bases){
        for(const n of names){
          list.push(b.endsWith('/')? (b+enc(n)) : (b.replace(/\/?$/,'/')+enc(n)));
        }
      }
      return Array.from(new Set(list));
    }

    const CANDIDATE_SRC = {
      green: buildCandidates("green"),
      pink:  buildCandidates("pink"),
      blue:  buildCandidates("blue"),
      purple:buildCandidates("purple")
    };

    const pickFirstAvailable = (urls)=>new Promise(resolve=>{
      let i=0;
      const tryNext=()=>{
        if(i>=urls.length){ resolve(null); return; }
        const img=new Image();
        img.onload = ()=>resolve(urls[i]);
        img.onerror= ()=>{ i++; tryNext(); };
        img.src = urls[i];
      };
      tryNext();
    });

    const useResolvedSources = ()=>{
      const [map,setMap] = useState({});
      useEffect(()=>{
        (async ()=>{
          const entries = await Promise.all(
            Object.keys(CANDIDATE_SRC).map(async key=>{
              const url = await pickFirstAvailable(CANDIDATE_SRC[key]);
              if(!url){ console.warn("ã‚­ãƒ£ãƒ©ç”»åƒæœªæ¤œå‡º:", key, CANDIDATE_SRC[key]); }
              return [key,url];
            })
          );
          setMap(Object.fromEntries(entries));
        })();
      },[]);
      return map;
    };

    /* =========================
       ã‚­ãƒ£ãƒ©æç”»ï¼ˆå¸ã„è¾¼ã¿å¯¾å¿œï¼‰
    ========================= */
    const CharacterImg = ({ x, y, src, scale=1, opacity=1, dragging=false }) => {
      const size = 110;
      if(!src){
        return <div className="absolute z-10 text-5xl bob"
          style={{left:x-24, top:y-48, transform: dragging?'scale(1.12)':'scale(1)', opacity}}>ğŸ™‚</div>;
      }
      return (
        <img src={src} alt=""
          className="absolute z-10 select-none pointer-events-none drop-shadow-xl bob face-left"
          style={{
            left:x - size*0.5, top:y - size*0.75, width:size, height:'auto',
            transform:`scaleX(-1) scale(${dragging?1.12*scale:scale})`,
            opacity
          }}/>
      );
    };

    /* =========================
       æœ¬ä½“
    ========================= */
    const WalkingGame = () => {
      const srcMap = useResolvedSources();
      const [currentScene, setCurrentScene] = useState(0);
      const [playerX, setPlayerX] = useState(120);
      const [playerY, setPlayerY] = useState(360);
      const [isWalking, setIsWalking] = useState(true);
      const [score, setScore] = useState(0);
      const [gameMessage, setGameMessage] = useState('æ•£æ­©ã‚’å§‹ã‚ã¾ã—ã‚‡ã†ï¼');
      const [isDragging, setIsDragging] = useState(false);
      const [collectedItems, setCollectedItems] = useState([]);
      const [gameOver, setGameOver] = useState(false);
      const [collectedInScene, setCollectedInScene] = useState([]);
      const [walkingSpeed] = useState(1.5);
      const [charName, setCharName] = useState(()=>localStorage.getItem('yorimichi_char') || 'green');

      // å¸ã„è¾¼ã¿æ¼”å‡ºç”¨
      const [falling, setFalling] = useState(false);
      const [fallProg, setFallProg] = useState(0); // 0â†’1
      const fallTarget = useRef({x:0,y:0});
      const rafId = useRef(null);

      const gameRef = useRef(null);

      const scenes = useMemo(()=>[
        { name:"èŠ±ç•‘ã®é“", background:"linear-gradient(to bottom,#87CEEB,#98FB98)",
          obstacles:[{type:"hole",x:300,y:400,width:80,height:60},{type:"hole",x:500,y:350,width:70,height:50}],
          distractions:[{type:"flower",x:200,y:200,emoji:"ğŸŒ¸"},{type:"flower",x:600,y:250,emoji:"ğŸŒº"},{type:"butterfly",x:450,y:180,emoji:"ğŸ¦‹"}] },
        { name:"æ£®ã®å°é“", background:"linear-gradient(to bottom,#228B22,#32CD32)",
          obstacles:[{type:"cliff",x:0,y:450,width:200,height:100},{type:"hole",x:400,y:380,width:90,height:70}],
          distractions:[{type:"mushroom",x:150,y:300,emoji:"ğŸ„"},{type:"squirrel",x:550,y:200,emoji:"ğŸ¿ï¸"},{type:"acorn",x:350,y:250,emoji:"ğŸŒ°"}] },
        { name:"å·è¾ºã®é“", background:"linear-gradient(to bottom,#87CEEB,#ADD8E6)",
          obstacles:[{type:"river",x:100,y:400,width:600,height:80},{type:"hole",x:250,y:300,width:60,height:50}],
          distractions:[{type:"fish",x:400,y:440,emoji:"ğŸ "},{type:"stone",x:180,y:350,emoji:"ğŸª¨"},{type:"frog",x:520,y:380,emoji:"ğŸ¸"}] },
        { name:"å²©å ´ã®é“", background:"linear-gradient(to bottom,#D2691E,#CD853F)",
          obstacles:[{type:"cliff",x:600,y:300,width:200,height:200},{type:"hole",x:200,y:400,width:100,height:80},{type:"hole",x:450,y:350,width:80,height:60}],
          distractions:[{type:"crystal",x:320,y:250,emoji:"ğŸ’"},{type:"lizard",x:150,y:300,emoji:"ğŸ¦"},{type:"cactus",x:550,y:200,emoji:"ğŸŒµ"}] },
        { name:"ãŠèŠ±è¦‹ã®é“", background:"linear-gradient(to bottom,#FFB6C1,#FFC0CB)",
          obstacles:[{type:"hole",x:350,y:380,width:120,height:90},{type:"cliff",x:0,y:420,width:150,height:80}],
          distractions:[{type:"sakura",x:200,y:150,emoji:"ğŸŒ¸"},{type:"sakura",x:500,y:200,emoji:"ğŸŒ¸"},{type:"bee",x:400,y:250,emoji:"ğŸ"},{type:"picnic",x:300,y:300,emoji:"ğŸ§º"}] },
        { name:"å¤•æš®ã‚Œã®é“", background:"linear-gradient(to bottom,#FF6347,#FF7F50)",
          obstacles:[{type:"hole",x:250,y:350,width:80,height:70},{type:"cliff",x:500,y:400,width:300,height:100}],
          distractions:[{type:"firefly",x:180,y:280,emoji:"âœ¨"},{type:"owl",x:450,y:200,emoji:"ğŸ¦‰"},{type:"moon",x:600,y:150,emoji:"ğŸŒ™"}] },
        { name:"ç ‚æ¼ ã®é“", background:"linear-gradient(to bottom,#F4A460,#DEB887)",
          obstacles:[{type:"quicksand",x:200,y:380,width:150,height:100},{type:"cliff",x:550,y:350,width:250,height:150},{type:"hole",x:400,y:320,width:70,height:60}],
          distractions:[{type:"camel",x:150,y:250,emoji:"ğŸª"},{type:"oasis",x:500,y:200,emoji:"ğŸï¸"},{type:"snake",x:350,y:280,emoji:"ğŸ"}] },
        { name:"é›ªã®é“", background:"linear-gradient(to bottom,#E6E6FA,#F0F8FF)",
          obstacles:[{type:"ice",x:300,y:350,width:200,height:120},{type:"hole",x:150,y:400,width:90,height:70}],
          distractions:[{type:"snowman",x:200,y:250,emoji:"â›„"},{type:"rabbit",x:450,y:280,emoji:"ğŸ°"},{type:"icicle",x:550,y:200,emoji:"ğŸ§Š"}] },
        { name:"ç«¹æ—ã®é“", background:"linear-gradient(to bottom,#228B22,#90EE90)",
          obstacles:[{type:"hole",x:250,y:380,width:100,height:80},{type:"cliff",x:500,y:420,width:300,height:80}],
          distractions:[{type:"panda",x:180,y:280,emoji:"ğŸ¼"},{type:"bamboo",x:400,y:200,emoji:"ğŸ‹"},{type:"dragonfly",x:350,y:250,emoji:"ğŸª°"}] },
        { name:"ã‚´ãƒ¼ãƒ«åœ°ç‚¹", background:"linear-gradient(to bottom,#FFD700,#FFA500)",
          obstacles:[{type:"final_pit",x:350,y:400,width:150,height:80}],
          distractions:[{type:"treasure",x:400,y:250,emoji:"ğŸ†"},{type:"rainbow",x:300,y:150,emoji:"ğŸŒˆ"},{type:"celebration",x:200,y:200,emoji:"ğŸ‰"}] }
      ],[]);

      useEffect(()=>{ setCollectedInScene([]); },[currentScene]);

      // è‡ªå‹•æ­©è¡Œ + å½“ãŸã‚Šåˆ¤å®š
      useEffect(()=>{
        let id;
        if(isWalking && !gameOver && !falling){
          id = setInterval(()=>{
            setPlayerX(prev=>{
              const newX = prev + walkingSpeed;
              const scene = scenes[currentScene];
              // å½“ãŸã‚Šåˆ¤å®š
              for(const o of scene.obstacles){
                const inX = newX>=o.x && newX<=o.x+o.width;
                const inY = playerY>=o.y && playerY<=o.y+o.height;
                if(inX && inY){
                  if(o.type==='hole' || o.type==='final_pit'){
                    // å¸ã„è¾¼ã¿æ¼”å‡º
                    startHoleSuction(o);
                  }else{
                    const names={hole:"ç©´",cliff:"å´–",river:"å·",quicksand:"æµç ‚",ice:"æ°·",final_pit:"æœ€å¾Œã®è½ã¨ã—ç©´"};
                    setGameMessage(`${names[o.type]||o.type}ã«è½ã¡ãŸï¼ãƒ‰ãƒ©ãƒƒã‚°ã§æˆ»ã—ã¦ï¼`);
                    setIsWalking(false);
                  }
                  return prev;
                }
              }
              // ã‚·ãƒ¼ãƒ³é·ç§»
              if(newX>750){
                if(currentScene<scenes.length-1){
                  setCurrentScene(s=>s+1);
                  setGameMessage(`${scenes[currentScene+1]?.name}ã«åˆ°ç€ï¼`);
                  return 50;
                }else{
                  setGameMessage("ãŠã‚ã§ã¨ã†ï¼ã‚´ãƒ¼ãƒ«ã§ã™ï¼ğŸ‰");
                  setIsWalking(false); setGameOver(true);
                  return prev;
                }
              }
              return newX;
            });
          },50);
        }
        return ()=>clearInterval(id);
      },[isWalking,currentScene,playerY,gameOver,falling]);

      // å¸ã„è¾¼ã¿ã®å®Ÿè£…
      function startHoleSuction(o){
        if(falling) return;
        // ç©´ã®ä¸­å¿ƒã¸
        const cx = o.x + o.width/2;
        const cy = o.y + o.height/2 + 6; // å°‘ã—ä¸‹å´ã¸
        fallTarget.current = {x:cx, y:cy};
        setFalling(true);
        setIsWalking(false);
        setGameMessage("ã‚ã£â€¦æ²¹æ–­ã—ãŸï¼ç©´ã«å¸ã„è¾¼ã¾ã‚Œã‚‹â€¦");
        const start = performance.now();
        const D = 700; // å¸ã„è¾¼ã¿æ™‚é–“(ms)

        cancelAnimationFrame(rafId.current);
        const tick = (t)=>{
          const p = Math.min(1, (t-start)/D);
          // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆé€Ÿâ†’é…ï¼‰
          const ease = 1 - Math.pow(1-p, 3);
          setPlayerX(x=> x + (cx - x) * 0.25); // å¾ã€…ã«ä¸­å¿ƒã¸
          setPlayerY(y=> y + (cy - y) * 0.25);
          setFallProg(ease);
          if(p<1){ rafId.current = requestAnimationFrame(tick); }
          else{
            // å¸ã„è¾¼ã¿å®Œäº† â†’ è½ä¸‹ã—ãŸæ„Ÿã˜ã§å¾…æ©Ÿ
            setGameMessage("è½ã¡ã¦ã—ã¾ã£ãŸâ€¦ãƒ‰ãƒ©ãƒƒã‚°ã§é“ã«æˆ»ã‚ã†");
          }
        };
        rafId.current = requestAnimationFrame(tick);
      }

      // ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œï¼ˆè½ä¸‹ä¸­ã§ã‚‚å¾©å¸°å¯èƒ½ï¼‰
      const startDrag = (e)=>{ setIsDragging(true); };
      const moveDrag = (nx,ny)=>{
        setPlayerX(Math.max(50,Math.min(750,nx)));
        setPlayerY(Math.max(150,Math.min(450,ny)));
        if(ny<350){
          setGameMessage("é“ã«æˆ»ã‚Šã¾ã—ãŸï¼");
          setIsWalking(true);
          setFalling(false); setFallProg(0);
        }
      };
      const onMouseMove=(e)=>{
        if(!isDragging) return;
        const r=gameRef.current.getBoundingClientRect();
        moveDrag(e.clientX-r.left, e.clientY-r.top);
      };
      const onTouchMove=(e)=>{
        e.preventDefault(); if(!isDragging) return;
        const t=e.touches[0], r=gameRef.current.getBoundingClientRect();
        moveDrag(t.clientX-r.left, t.clientY-r.top);
      };

      const collectItem=(item, idx)=>{
        if(collectedInScene.includes(idx)) return;
        setCollectedItems(ci=>[...ci,item]);
        setCollectedInScene(cs=>[...cs,idx]);
        setScore(s=>s+10);
        setGameMessage(`${item.emoji} ã‚’è¦‹ã¤ã‘ãŸï¼+10ç‚¹`);
      };

      const scene = scenes[currentScene];
      const chooseChar = (name)=>{ setCharName(name); localStorage.setItem('yorimichi_char',name); };

      // å¸ã„è¾¼ã¿ä¸­ã®ã‚¹ã‚±ãƒ¼ãƒ«ãƒ»é€æ˜åº¦
      const fallScale = falling ? (1 - 0.75*fallProg) : 1;
      const fallOpacity = falling ? (1 - 0.85*fallProg) : 1;

      return (
        <div className="game-container">
          <div className="mb-4 text-white text-center">
            <h1 className="text-4xl font-bold mb-4">ğŸš¶â€â™‚ï¸ å¯„ã‚Šé“ã®æ•£æ­©ã‚²ãƒ¼ãƒ  ğŸŒ¸</h1>

            <div className="flex items-center gap-3 bg-indigo-900/40 px-3 py-2 rounded-lg shadow">
              <span className="text-white text-sm">ä»²é–“ã‚’ãˆã‚‰ã¶ï¼š</span>
              {["green","pink","blue","purple"].map((c)=>(
                <button key={c} onClick={()=>chooseChar(c)}
                        className={`rounded-lg p-1 bg-white ${localStorage.getItem('yorimichi_char')===c?'ring-4 ring-yellow-300':''}`}>
                  {srcMap[c]
                    ? <img src={srcMap[c]} alt={c} className="w-12 h-12 object-contain face-left" />
                    : <span className="w-12 h-12 grid place-items-center">ğŸ™‚</span>}
                </button>
              ))}
            </div>

            <div className="mt-3 flex justify-center gap-6 text-lg bg-black/30 p-3 rounded-lg">
              <div className="font-semibold">ã‚·ãƒ¼ãƒ³: {currentScene+1}/10</div>
              <div className="font-semibold">ğŸ“ {scene.name}</div>
              <div className="font-semibold">ğŸ¯ ã‚¹ã‚³ã‚¢: {score}</div>
              <div className="font-semibold">ğŸ åé›†: {collectedItems.length}å€‹</div>
            </div>
          </div>

          <div
            ref={gameRef}
            className="relative border-4 border-white rounded-lg overflow-hidden cursor-crosshair shadow-2xl"
            style={{width:'800px',height:'500px',background:scene.background}}
            onMouseDown={startDrag} onMouseMove={onMouseMove} onMouseUp={()=>setIsDragging(false)}
            onTouchStart={(e)=>{e.preventDefault();startDrag();}} onTouchMove={onTouchMove} onTouchEnd={()=>setIsDragging(false)}
          >
            <div className="absolute top-0 left-0 w-full h-[350px] bg-gradient-to-b from-transparent to-yellow-200 opacity-30"></div>

            {scene.obstacles.map((o,i)=>{
              const baseClass =
                o.type==='hole' ? 'bg-black/95' :
                o.type==='cliff'? 'bg-gray-600' :
                o.type==='river'? 'bg-blue-400' :
                o.type==='quicksand'? 'bg-yellow-700' :
                o.type==='ice'? 'bg-blue-200' :
                o.type==='final_pit'? 'bg-red-900' : 'bg-gray-500';
              const isHole = (o.type==='hole' || o.type==='final_pit');
              return (
                <div key={i}
                  className={`absolute border-2 border-black/60 ${baseClass} ${isHole?'hole rounded-full':''}`}
                  style={{left:o.x, top:o.y, width:o.width, height:o.height, borderRadius: isHole?'9999px':'0'}}
                >
                  {/* è¦‹å‡ºã—ã¯éè¡¨ç¤ºã«ã—ã¾ã—ãŸï¼ˆæ¼”å‡ºå„ªå…ˆï¼‰ */}
                </div>
              );
            })}

            {scene.distractions.map((it,i)=>{
              if(collectedInScene.includes(i)) return null;
              return (
                <div key={i} className="absolute cursor-pointer hover:scale-125 transition-transform"
                     style={{left:it.x,top:it.y}} onClick={()=>collectItem(it,i)}>
                  <div className="text-4xl pulse">{it.emoji}</div>
                </div>
              );
            })}

            <CharacterImg x={playerX} y={playerY} src={srcMap[charName]}
              dragging={isDragging} scale={fallScale} opacity={fallOpacity} />

            <div className="absolute top-2 right-2 bg-black/70 text-white p-3 rounded-lg">
              <div className="text-sm font-bold mb-1">åé›†ã—ãŸã‚¢ã‚¤ãƒ†ãƒ :</div>
              <div className="flex flex-wrap gap-1 max-w-[200px]">
                {collectedItems.slice(-12).map((it,i)=>(<span key={i} className="text-2xl">{it.emoji}</span>))}
              </div>
            </div>

            <div className="absolute bottom-2 left-2 right-2 h-3 bg-black/30 rounded-full">
              <div className="h-full bg-green-400 rounded-full transition-all duration-300"
                   style={{width: ((currentScene+1)/scenes.length*100)+'%'}}></div>
            </div>
          </div>

          <div className="mt-4 text-white text-center bg-black/50 p-6 rounded-lg max-w-[800px]">
            <div className="text-2xl font-bold mb-2">{gameMessage}</div>
            <div className="text-base text-gray-300">
              {gameOver ? "ğŸ‰ ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼ç´ æ™´ã‚‰ã—ã„æ•£æ­©ã§ã—ãŸï¼"
                        : isWalking ? "ğŸš¶â€â™‚ï¸ è‡ªå‹•ã§æ­©ã„ã¦ã„ã¾ã™ã€‚å¯„ã‚Šé“ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦åé›†ã—ã‚ˆã†ï¼"
                                    : "æŒ‡ã§ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦é“ã«æˆ»ã—ã¦ãã ã•ã„"}
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<WalkingGame />);
  </script>
</body>
</html>
